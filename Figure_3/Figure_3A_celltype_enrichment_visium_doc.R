# ============================================================================
# Spatial Transcriptomics Celltrek visualization
# Author: [Saad Khan]   |   Date: 2025-05-23
# Description: Integrates spatial & single-cell data, performs enrichment
#              and visualization of tumor microenvironment cell states.
# ============================================================================

# ----------------------------
# Load Required Libraries
# ----------------------------

# Core scRNA-seq + spatial processing
library(SingleCellExperiment)
library(scuttle)
library(scran)
library(scater)
library(scRNAseq)
library(Seurat)

# Utilities and enhancements
library(BiocParallel)       # Parallel computation
library(yaml)               # Configuration files
library(Ckmeans.1d.dp)      # 1D clustering
library(stringr)            # String handling
library(dplyr)              # Data manipulation
library(sctransform)        # SCTransform normalization
library(ggplot2)            # General plotting
library(future)             # Parallel plans
library(RColorBrewer)       # Color palettes
library(circlize)           # Circular plots
library(scCustomize)        # Seurat customization

# Heatmaps, annotations, and data reshaping
library(ComplexHeatmap)
library(CellTagR)
library(reshape2)
library(clusterProfiler)
library(org.Hs.eg.db)
library(CellTrek)

# Plot enhancements
library(ggdendro)
library(cowplot)
library(tidyverse)
library(ggtree)             # Phylogenetic plotting
library(patchwork)          # Plot composition
library(gridExtra)
library(gtools)

# ----------------------------
# Set Global Options
# ----------------------------

set.seed(12345L)  # Reproducibility
date <- gsub("2025-", "25", Sys.Date(), perl = TRUE)
date <- gsub("-", "", date)

# ----------------------------
# Load Initial Data
# ----------------------------

# Load integrated Seurat object with cluster annotations
# gs://fc-secure-5f3422d7-9911-4ab3-8091-69df773f5abf/RPCA_Clustering/RPCA_Clustering_by_patient/merged.patient.combined.integ_sub.rds
merged.patient.combined.integ_sub <- readRDS('/n/scratch/users/s/sak4832/Feb2_2025/Dec27_2024/cluster_distances/merged.patient.combined.integ_sub.rds')

# Load reference Seurat object from scRNA-seq (used for CellTrek)
single_cell_ref <- readRDS('/n/scratch/users/s/sak4832/scrna_seq_ref_celltrek_orig_latestcellstateannotations.rds')
# latest single cell reference here gs://fc-secure-5f3422d7-9911-4ab3-8091-69df773f5abf/Single_cell_reference_latest/scrna_seq_ref_celltrek_orig_latestcellstateannotations.rds

# ----------------------------
# Function: Collapse Fine to Broad Celltypes
# ----------------------------

make_broad_celltypes2 <- function(single_cell_ref) {
  # Create mapping dataframe from fine to broad celltypes
  mydf <- data.frame(names(table(single_cell_ref$Celltypes_Aug8_2024)))
  names(mydf) <- c('all_celltypes')
  mydf$broad_celltypes <- NA
  
  # Map fine celltypes to higher-level categories
  mydf$broad_celltypes[grep('CD4_', mydf$all_celltypes)] <- 'CD4_Tcells'
  mydf$broad_celltypes[grep('CD8_', mydf$all_celltypes)] <- 'CD8_Tcells'
  mydf$broad_celltypes[grep('MAIT-like|Proliferating|T_EMRA|T_IFNG_stimulated', mydf$all_celltypes)] <- 'Other_Tcells'
  mydf$broad_celltypes[grep('TAM', mydf$all_celltypes)] <- 'TAMs'
  mydf$broad_celltypes[grep('Vascular|Pericyte', mydf$all_celltypes)] <- 'Vascular'
  mydf$broad_celltypes[grep('Fibroblast', mydf$all_celltypes)] <- 'Fibroblast'
  mydf$broad_celltypes[grep('Microglia', mydf$all_celltypes)] <- 'Microglia'
  mydf$broad_celltypes[grep('Monocyte', mydf$all_celltypes)] <- 'Monocyte'
  mydf$broad_celltypes[grep('Choroid plexus|Ependymal|Ex. Neuron|Inhib. Neuron|Neuron', mydf$all_celltypes)] <- 'Neuron'
  mydf$broad_celltypes[grep('DC', mydf$all_celltypes)] <- 'DC'

  # Direct assignments for discrete types
  mydf$broad_celltypes[mydf$all_celltypes == 'Oligodendrocyte'] <- 'Oligodendrocyte'
  mydf$broad_celltypes[mydf$all_celltypes == 'Oligodendrocyte precursor'] <- 'Oligodendrocyte precursor'
  mydf$broad_celltypes[mydf$all_celltypes == 'Committed oligodendrocyte precursor'] <- 'Committed oligodendrocyte precursor'
  mydf$broad_celltypes[mydf$all_celltypes == 'Astrocyte'] <- 'Astrocyte'
  mydf$broad_celltypes[mydf$all_celltypes == 'B cells'] <- 'Bcells'
  mydf$broad_celltypes[mydf$all_celltypes %in% c('NK', 'NK-like')] <- 'NK/NK-like'

  # tumor states
  mydf$broad_celltypes[mydf$all_celltypes == 'M1'] <- 'M1'
  mydf$broad_celltypes[mydf$all_celltypes == 'M2'] <- 'M2'
  mydf$broad_celltypes[mydf$all_celltypes == 'M3'] <- 'M3'
  mydf$broad_celltypes[mydf$all_celltypes == 'M4'] <- 'M4'
  mydf$broad_celltypes[mydf$all_celltypes == 'M5'] <- 'M5'

  # Join with Seurat object to assign broad types
  mydf2 <- data.frame(cellnames = names(single_cell_ref$Celltypes_Aug8_2024),
                      Celltypes_Aug8_2024 = unname(single_cell_ref$Celltypes_Aug8_2024))

  mydf12 <- mydf2 %>% left_join(mydf, by = c("Celltypes_Aug8_2024" = "all_celltypes"))

  # Map to object metadata
  index <- match(Cells(single_cell_ref), mydf12$cellnames)
  single_cell_ref$broad_celltypes <- mydf12$broad_celltypes[index]

  return(single_cell_ref)
}

# Apply broad mapping to reference
single_cell_ref2 <- make_broad_celltypes2(single_cell_ref)

# ---------------------------------------------------------------------------
# Load Individual Visium Spatial Samples
# ---------------------------------------------------------------------------

#spatial_input.txt contains path to invidivual visium seurat objects
# Read the spatial input table that lists Seurat RDS files (one per sample)
spatial_inp <- read.table('/n/data1/mgh/neuro/petti/lab/Users/khan.saad/spatial_input.txt')

# Initialize list to hold all spatial Seurat objects
seurat_obj_list <- list()

#filtered seurat object list from here
# gs://fc-secure-5f3422d7-9911-4ab3-8091-69df773f5abf/RPCA_Clustering/RPCA_Clustering_by_patient/seurat_obj_list2.rds

# Loop through spatial input and read in each sample
for (i in 1:nrow(spatial_inp)) {
  visium_obj <- readRDS(spatial_inp$V2[i])  # Load Visium Seurat object
  sample_name <- names(visium_obj@images)[1]  # Extract sample name from image slot
  seurat_obj_list[[sample_name]] <- visium_obj  # Store in list by sample name
}

# ---------------------------------------------------------------------------
# Extract RPCA Clustering Metadata and Merge into Spatial Objects
# ---------------------------------------------------------------------------

# Select relevant columns from RPCA Seurat object metadata
rpca_meta <- merged.patient.combined.integ_sub@meta.data[
  c("Sample", "Patient",
    "integrated_snn_res.0.1", "integrated_snn_res.0.3", "integrated_snn_res.0.5",
    "integrated_snn_res.0.7", "integrated_snn_res.0.9", "integrated_snn_res.1.2")
]

# Add cell-level identifiers
rpca_meta$cellname <- rownames(rpca_meta)
rpca_meta$cellname2 <- str_split_i(rpca_meta$cellname, '_', 2)  # Extract barcodes
rpca_meta$sample <- str_split_i(rpca_meta$cellname, '_', 1)     # Extract sample names

# Split metadata by sample name for easier merging
rpca_meta_list <- split(rpca_meta, rpca_meta$sample)

# Merge RPCA cluster info into each Visium Seurat object
for (i in names(seurat_obj_list)) {
  rpca_meta_list_sub <- rpca_meta_list[[i]]
  index <- match(Cells(seurat_obj_list[[i]]), rpca_meta_list_sub$cellname2)
  
  # Attach metadata columns to the spatial Seurat objects
  seurat_obj_list[[i]]$Patient <- rpca_meta_list_sub$Patient[index]
  seurat_obj_list[[i]]$Sample <- rpca_meta_list_sub$Sample[index]
  seurat_obj_list[[i]]$integrated_snn_res.0.1 <- rpca_meta_list_sub$integrated_snn_res.0.1[index]
  seurat_obj_list[[i]]$integrated_snn_res.0.3 <- rpca_meta_list_sub$integrated_snn_res.0.3[index]
  seurat_obj_list[[i]]$integrated_snn_res.0.5 <- rpca_meta_list_sub$integrated_snn_res.0.5[index]
  seurat_obj_list[[i]]$integrated_snn_res.0.7 <- rpca_meta_list_sub$integrated_snn_res.0.7[index]
  seurat_obj_list[[i]]$integrated_snn_res.0.9 <- rpca_meta_list_sub$integrated_snn_res.0.9[index]
  seurat_obj_list[[i]]$integrated_snn_res.1.2 <- rpca_meta_list_sub$integrated_snn_res.1.2[index]
}


# ---------------------------------------------------------------------------
# Load CellTrek Spot-to-Cell Mapping Inputs (No Interpolation)
# ---------------------------------------------------------------------------

# This file has 2 columns: sample ID and path to RDS file of spot-to-cell assignments
celltrek_no_interpolation_celltypes_inp <- read.table(
  '/n/data1/mgh/neuro/petti/lab/Users/khan.saad/RPCA_clustering_and_spots_Ligrec_summary/celltrek_no_interpolation_celltypes_inp2.txt'
)

# Extract and standardize sample names
celltrek_no_interpolation_celltypes_inp$sample_name <- celltrek_no_interpolation_celltypes_inp$V1
celltrek_no_interpolation_celltypes_inp$sample_name2 <- gsub("-", ".", celltrek_no_interpolation_celltypes_inp$sample_name, perl = TRUE)

# ---------------------------------------------------------------------------
# Sample Name Mapping (Raw â†’ Formatted Names in Seurat)
# ---------------------------------------------------------------------------

# Manually map known sample naming inconsistencies for downstream merging
mysample_map <- data.frame(
  sample_name = c(
    "B172-01", "B172-02", "B176-01-02", "B176-02-01", "B176-02-04", "B178-02-01",
    "B185-01", "B185-02", "B185-03", "B186-01", "B186-02", "B186-03", "B186-04",
    "ST073021-2", "ST073021-4", "WU1220-1", "WU1220-2", "WU1220-3",
    "WU1221-Core2", "WU1221-Edge1", "WU1227-Core5", "WU1227-Edge2"
  )
)

# Make R-safe image names
mysample_map$image_name <- make.names(mysample_map$sample_name)

# Fix known naming mismatches between CellTrek and Seurat
mysample_map$image_name[mysample_map$sample_name == 'ST073021-2'] <- 'ST073021.02'
mysample_map$image_name[mysample_map$sample_name == 'ST073021-4'] <- 'ST073021.04'
mysample_map$image_name[mysample_map$sample_name == 'WU1220-1'] <- 'WU1220.01'
mysample_map$image_name[mysample_map$sample_name == 'WU1220-2'] <- 'WU1220.02'
mysample_map$image_name[mysample_map$sample_name == 'WU1220-3'] <- 'WU1220.03'
mysample_map$image_name[mysample_map$sample_name == 'WU1227-Core5'] <- 'WU1227.Core5'
mysample_map$image_name[mysample_map$sample_name == 'WU1227-Edge2'] <- 'WU1227.Edge2'
mysample_map$image_name[mysample_map$sample_name == 'WU1221-Core2'] <- 'WU1221.Core'
mysample_map$image_name[mysample_map$sample_name == 'WU1221-Edge1'] <- 'WU1221.Edge'

# Match mapping info to CellTrek input
index <- match(celltrek_no_interpolation_celltypes_inp$sample_name, mysample_map$sample_name)
celltrek_no_interpolation_celltypes_inp$sample_map <- mysample_map$image_name[index]

# Adjust sample name for final use with Seurat list
celltrek_no_interpolation_celltypes_inp$sample_name_final <- celltrek_no_interpolation_celltypes_inp$sample_map
celltrek_no_interpolation_celltypes_inp$sample_name_final[
  celltrek_no_interpolation_celltypes_inp$sample_map == 'WU1221.Core'
] <- 'WU1221.Core2'
celltrek_no_interpolation_celltypes_inp$sample_name_final[
  celltrek_no_interpolation_celltypes_inp$sample_map == 'WU1221.Edge'
] <- 'WU1221.Edge1'


# ---------------------------------------------------------------------------
# Function: Map Spot-to-Cell Assignments to Broad Cell Types
# ---------------------------------------------------------------------------

get_celltrek_celltypes_from_no_interpolation_reverse_engineer <- function(
  sample_name,
  spot_to_cell_list_rds,
  single_cell_ref,
  seurat_obj
) {
  # Load list of data frames, each representing cells assigned to a spot
  split_list_by_spot <- readRDS(spot_to_cell_list_rds)

  # Standardize names for joining
  formatted_names_scref <- make.names(Cells(single_cell_ref))
  scref_meta <- single_cell_ref@meta.data[c('Celltypes_Aug8_2024', 'broad_celltypes')]
  scref_meta$cellnames <- make.names(rownames(scref_meta))

  # Merge single-cell metadata into each spot assignment
  split_list_by_spot2 <- lapply(split_list_by_spot, function(x) {
    x %>% left_join(scref_meta, by = c("Var1" = "cellnames"))
  })

  # Add spot name column to each element
  split_list_by_spot3 <- lapply(names(split_list_by_spot2), function(x) {
    split_list_by_spot2[[x]]$spot_name <- x
    return(split_list_by_spot2[[x]])
  })

  # Combine all spot data into one big data frame
  split_list_by_spot_df <- do.call(rbind, split_list_by_spot3)

  # Count number of each broad cell type per spot
  broad_celltype_count <- split_list_by_spot_df %>% group_by(spot_name) %>% dplyr::count(broad_celltypes)
  all_celltype_count   <- split_list_by_spot_df %>% group_by(spot_name) %>% dplyr::count(Celltypes_Aug8_2024)

  # Convert to wide format (spot_name as rows, celltypes as columns)
  broad_celltype_mat <- broad_celltype_count %>% dcast(spot_name ~ broad_celltypes)
  all_celltype_mat   <- all_celltype_count %>% dcast(spot_name ~ Celltypes_Aug8_2024)

  # Replace NA with 0 (means no cells of that type in that spot)
  broad_celltype_mat[is.na(broad_celltype_mat)] <- 0
  all_celltype_mat[is.na(all_celltype_mat)] <- 0

  # Compute total cell count per spot
  mysel_broad <- colnames(broad_celltype_mat)[-1]
  mysel_all   <- colnames(all_celltype_mat)[-1]
  broad_celltype_mat$total_cell_count <- rowSums(broad_celltype_mat[mysel_broad])
  all_celltype_mat$total_cell_count   <- rowSums(all_celltype_mat[mysel_all])

  # Map back to Seurat spot IDs
  spot_id_df <- data.frame(spot_id = Cells(seurat_obj), spot_name = make.names(Cells(seurat_obj)))
  broad_celltype_mat2 <- merge(spot_id_df, broad_celltype_mat, by = 'spot_name')
  all_celltype_mat2   <- merge(spot_id_df, all_celltype_mat, by = 'spot_name')

  # Remove redundant spot_name column (spot_id is now used)
  broad_celltype_mat2$spot_name <- NULL
  all_celltype_mat2$spot_name   <- NULL

  # Return both broad and all celltype matrices for this sample
  return(list(
    'broad_celltypes_per_spot' = broad_celltype_mat2,
    'all_celltypes_per_spot'   = all_celltype_mat2
  ))
}

# ---------------------------------------------------------------------------
# Run Spot-to-Cell Mapping Across All Samples
# ---------------------------------------------------------------------------

#spot_to_cell_list_rds is the output of the reverse-engineered celltrek code for each sample.

# Initialize result list
spots_to_cells_celltrek_annotations <- list()

# Loop through all CellTrek samples and run the mapping function
for (i in 1:nrow(celltrek_no_interpolation_celltypes_inp)) {
  mysamp <- celltrek_no_interpolation_celltypes_inp$sample_name_final[i]
  spot_to_cell_list_rds <- celltrek_no_interpolation_celltypes_inp$V2[i]

  # Generate spot â†’ cell type counts for the sample
  spots_to_cells_celltrek_annotations[[mysamp]] <- get_celltrek_celltypes_from_no_interpolation_reverse_engineer(
    sample_name = mysamp,
    spot_to_cell_list_rds = spot_to_cell_list_rds,
    single_cell_ref = single_cell_ref2,
    seurat_obj = seurat_obj_list[[mysamp]]
  )
}


# ---------------------------------------------------------------------------
# Subset Seurat Objects by Selected Clusters (e.g. 0.9 resolution)
# ---------------------------------------------------------------------------

# Define which clustering resolution to use
integ_clus_vec <- 'integrated_snn_res.0.9'

# Drop unused factor levels in cluster assignments
merged.patient.combined.integ_sub$integrated_snn_res.0.9 <- droplevels(
  merged.patient.combined.integ_sub$integrated_snn_res.0.9
)

# Extract list of all cluster IDs from the chosen resolution
sel_clus2 <- levels(merged.patient.combined.integ_sub$integrated_snn_res.0.9)

# Subset each Seurat object to retain only clusters of interest
seurat_obj_list2 <- lapply(names(seurat_obj_list), function(x) {
  Idents(seurat_obj_list[[x]]) <- integ_clus_vec
  DefaultAssay(seurat_obj_list[[x]]) <- 'Spatial'

  seurat_sub <- subset(seurat_obj_list[[x]], idents = intersect(
    unique(Idents(seurat_obj_list[[x]])), sel_clus2
  ))

  print(x)
  print(length(Cells(seurat_sub)))
  print(length(Cells(seurat_obj_list[[x]])))

  return(seurat_sub)
})
names(seurat_obj_list2) <- names(seurat_obj_list)

# ---------------------------------------------------------------------------
# Read Final Cluster Colors (for visualization)
# ---------------------------------------------------------------------------

final_cluster_colors <- readRDS('/n/scratch/users/s/sak4832/Feb2_2025/Dec27_2024/cluster_distances/final_cluster_colors.rds')
# final_cluster_colors.rds cluster color mapping provided in github

# ---------------------------------------------------------------------------
#  Count Spots by Cluster
# ---------------------------------------------------------------------------

noofspots_by_cluster <- function(sample_name, spots_to_cells_celltrek_annotations,
                                 type_name, seurat_obj_list2, integ_clus) {
  # Extract data for the selected sample
  all_celltypes_per_spot2 <- spots_to_cells_celltrek_annotations[[sample_name]][[type_name]]

  # Get Seurat cluster assignments
  seurat_obj_samp <- seurat_obj_list2[[sample_name]]
  seurat_obj_meta <- seurat_obj_samp@meta.data[c(integ_clus)]
  seurat_obj_meta$spot_id <- rownames(seurat_obj_meta)

  # Subset spot data to include only those in Seurat object
  all_celltypes_per_spot2_melt_sub <- subset(all_celltypes_per_spot2,
                                             spot_id %in% seurat_obj_meta$spot_id)

  # Merge metadata and count spots per cluster
  melt_df <- all_celltypes_per_spot2_melt_sub %>% left_join(seurat_obj_meta, by = "spot_id")
  noofspots_by_cluster2 <- melt_df %>% group_by(!!sym(integ_clus)) %>%
    summarize(spot_count = n())

  return(noofspots_by_cluster2)
}

# ---------------------------------------------------------------------------
# Function: Compute Spot Counts Per Cluster Across All Samples
# ---------------------------------------------------------------------------

get_spot_count_bycluster <- function(
  spots_to_cells_celltrek_annotations,
  type_name,
  integ_clus_vec,
  seurat_obj_list2 = seurat_obj_list2
) {
  integ_clus_vec_spot_count <- list()

  # Loop over cluster resolutions (usually just one)
  for (integs in integ_clus_vec) {
    for (sample_name in names(spots_to_cells_celltrek_annotations)) {
      integ_clus_vec_spot_count[[integs]][[sample_name]] <- noofspots_by_cluster(
        sample_name = sample_name,
        spots_to_cells_celltrek_annotations = spots_to_cells_celltrek_annotations,
        type_name = type_name,
        seurat_obj_list2 = seurat_obj_list2,
        integ_clus = integs
      )
    }
  }

  # Combine results across samples
  integ_clus_vec_spot_count_combined <- lapply(
    names(integ_clus_vec_spot_count),
    function(x) {
      mytemp <- do.call(rbind, integ_clus_vec_spot_count[[x]])
      rownames(mytemp) <- NULL
      return(mytemp)
    }
  )
  names(integ_clus_vec_spot_count_combined) <- names(integ_clus_vec_spot_count)

  # Summarize spot count per cluster
  integ_clus_vec_spot_count_combined_sumbyclus <- lapply(
    names(integ_clus_vec_spot_count_combined),
    function(x) {
      integ_clus_vec_spot_count_combined[[x]] %>%
        group_by(!!sym(x)) %>%
        summarize(spot_count_bycluster = sum(spot_count))
    }
  )
  names(integ_clus_vec_spot_count_combined_sumbyclus) <- names(integ_clus_vec_spot_count_combined)

  return(integ_clus_vec_spot_count_combined_sumbyclus)
}

# ---------------------------------------------------------------------------
# Function: Melt Celltype Proportions for One Sample
# ---------------------------------------------------------------------------

melt_by_samples_sub <- function(
  sample_name,
  spots_to_cells_celltrek_annotations,
  type_name,
  seurat_obj_list2,
  integ_clus
) {
  # Get celltype matrix for selected sample
  all_celltypes_per_spot2 <- spots_to_cells_celltrek_annotations[[sample_name]][[type_name]]
  all_celltypes_per_spot2_melt <- melt(all_celltypes_per_spot2, id = 'spot_id')

  # Get cluster info from Seurat object
  seurat_obj_samp <- seurat_obj_list2[[sample_name]]
  seurat_obj_meta <- seurat_obj_samp@meta.data[c(integ_clus)]
  seurat_obj_meta$spot_id <- rownames(seurat_obj_meta)

  # Filter melted data to only keep present spots
  all_celltypes_per_spot2_melt_sub <- subset(all_celltypes_per_spot2_melt,
                                             spot_id %in% seurat_obj_meta$spot_id)

  # Merge and summarize celltype counts per cluster
  melt_df <- all_celltypes_per_spot2_melt_sub %>% left_join(seurat_obj_meta, by = "spot_id")
  celltype_count_rpca_clusters <- melt_df %>%
    group_by(variable, !!sym(integ_clus)) %>%
    summarize(count = sum(value))

  # Filter out total_cell_count rows
  celltype_count_rpca_clusters_sub <- subset(celltype_count_rpca_clusters,
                                             variable != 'total_cell_count')
  celltype_count_rpca_clusters_sub$variable <- droplevels(celltype_count_rpca_clusters_sub$variable)
  celltype_count_rpca_clusters_sub$sample_name <- sample_name

  return(celltype_count_rpca_clusters_sub)
}

# ---------------------------------------------------------------------------
# Function: Get Celltype Count by Cluster Across Samples
# ---------------------------------------------------------------------------

get_celltype_by_integclus <- function(
  spots_to_cells_celltrek_annotations,
  type_name,
  integ_clus_vec,
  seurat_obj_list2 = seurat_obj_list2
) {
  integ_clus_vec_celltypes <- list()

  for (integs in integ_clus_vec) {
    for (sample_name in names(spots_to_cells_celltrek_annotations)) {
      integ_clus_vec_celltypes[[integs]][[sample_name]] <- melt_by_samples_sub(
        sample_name = sample_name,
        spots_to_cells_celltrek_annotations = spots_to_cells_celltrek_annotations,
        type_name = type_name,
        seurat_obj_list2 = seurat_obj_list2,
        integ_clus = integs
      )
    }
  }

  # Combine data from all samples
  integ_clus_vec_celltypes_combined <- lapply(
    names(integ_clus_vec_celltypes),
    function(x) {
      mytemp <- do.call(rbind, integ_clus_vec_celltypes[[x]])
      rownames(mytemp) <- NULL
      return(mytemp)
    }
  )
  names(integ_clus_vec_celltypes_combined) <- names(integ_clus_vec_celltypes)

  # Summarize total counts per cluster per celltype
  integ_clus_vec_celltypes_combined_sumbyclus <- lapply(
    names(integ_clus_vec_celltypes_combined),
    function(x) {
      integ_clus_vec_celltypes_combined[[x]] %>%
        group_by(variable, !!sym(x)) %>%
        summarize(celltype_count_by_cluster = sum(count))
    }
  )
  names(integ_clus_vec_celltypes_combined_sumbyclus) <- names(integ_clus_vec_celltypes_combined)

  return(integ_clus_vec_celltypes_combined_sumbyclus)
}

# ---------------------------------------------------------------------------
# Function: Compute Tumor Fraction by Cluster (per sample)
# ---------------------------------------------------------------------------

get_tumor_fraction_by_cluster <- function(
  spots_to_cells_celltrek_annotations,
  type_name,
  integ_clus_vec,
  seurat_obj_list2 = seurat_obj_list2,
  sample_name
) {
  # Extract spot-level celltype matrix
  mysel_celltrek <- spots_to_cells_celltrek_annotations[[sample_name]][[type_name]]

  # Define tumor vs non-tumor celltypes
  all_cell_cols <- intersect(colnames(mysel_celltrek), c(
    "Astrocyte", "Bcells", "CD4_Tcells", "CD8_Tcells",
    "Committed oligodendrocyte precursor", "DC", "Fibroblast", "M1", "M2", "M3", "M4", "M5",
    "Microglia", "Monocyte", "Neuron", "NK/NK-like", "Oligodendrocyte",
    "Oligodendrocyte precursor", "Other_Tcells", "TAMs", "Vascular"
  ))
  tumor_cols <- intersect(colnames(mysel_celltrek), c("M1", "M2", "M3", "M4", "M5"))

  # Compute tumor fraction = tumor / total cells in spot
  mysel_celltrek$tumor_fraction <- rowSums(mysel_celltrek[tumor_cols]) /
                                   rowSums(mysel_celltrek[all_cell_cols])

  # Reduce to spot ID and tumor fraction
  mysel_celltrek_sub <- mysel_celltrek[c('spot_id', 'tumor_fraction')]

  # Get Seurat metadata for the sample
  seurat_obj_samp <- seurat_obj_list2[[sample_name]]
  seurat_obj_meta <- seurat_obj_samp@meta.data[c(integ_clus_vec)]
  seurat_obj_meta$spot_id <- rownames(seurat_obj_meta)

  # Merge tumor fractions with Seurat cluster metadata
  all_celltypes_per_spot2_melt_sub <- subset(mysel_celltrek_sub, spot_id %in% seurat_obj_meta$spot_id)
  mytumor_frac_by_sample <- all_celltypes_per_spot2_melt_sub %>%
    left_join(seurat_obj_meta, by = "spot_id")

  mytumor_frac_by_sample$spot_name <- paste0(sample_name, '_', mytumor_frac_by_sample$spot_id)

  # Return dataframe with cluster and tumor fraction per spot
  return(mytumor_frac_by_sample[c('spot_name', 'integrated_snn_res.0.9', 'tumor_fraction')])
}

# ---------------------------------------------------------------------------
#  Tumor Fraction Calculation for All Samples
# ---------------------------------------------------------------------------

tumor_fraction_list <- list()

for (sample_name in names(seurat_obj_list2)) {
  tumor_fraction_list[[sample_name]] <- get_tumor_fraction_by_cluster(
    spots_to_cells_celltrek_annotations = spots_to_cells_celltrek_annotations,
    type_name = 'broad_celltypes_per_spot',
    integ_clus_vec = integ_clus_vec,
    seurat_obj_list = seurat_obj_list2,
    sample_name = sample_name
  )
}

# Combine tumor fractions into one data frame
tumor_fraction_df <- do.call(rbind, tumor_fraction_list)
rownames(tumor_fraction_df) <- NULL

# ---------------------------------------------------------------------------
#  Spot Count Per Cluster (for chosen resolution)
# ---------------------------------------------------------------------------

integ_clus_vec_spot_count_integrated_snn_res.0.9 <- get_spot_count_bycluster(
  spots_to_cells_celltrek_annotations = spots_to_cells_celltrek_annotations,
  type_name = 'broad_celltypes_per_spot',
  integ_clus_vec = integ_clus_vec,
  seurat_obj_list = seurat_obj_list2
)

# ---------------------------------------------------------------------------
#   Celltype Count Per Cluster
# ---------------------------------------------------------------------------

integ_clus_vec_celltypes_integrated_snn_res.0.9 <- get_celltype_by_integclus(
  spots_to_cells_celltrek_annotations = spots_to_cells_celltrek_annotations,
  type_name = 'broad_celltypes_per_spot',
  integ_clus_vec = integ_clus_vec,
  seurat_obj_list = seurat_obj_list2
)

# Pull out the one result (since only one integ_clus_vec was used)
celltype_data <- integ_clus_vec_celltypes_integrated_snn_res.0.9$integrated_snn_res.0.9
celltype_data$integrated_snn_res.0.9 <- droplevels(celltype_data$integrated_snn_res.0.9)

# Merge spot count and celltype data
celltype_proportion_byspotcountcluster <- celltype_data %>%
  left_join(integ_clus_vec_spot_count_integrated_snn_res.0.9$integrated_snn_res.0.9,
            by = c("integrated_snn_res.0.9"))

# ---------------------------------------------------------------------------
# Compute Enrichment Score Per Celltype Per Cluster
# ---------------------------------------------------------------------------

get_enrichment_score_for_eachcelltype <- function(
  celltype_proportion_byspotcountcluster,
  celltype,
  spot_count_bycluster
) {
  df_sub <- subset(celltype_proportion_byspotcountcluster, variable == celltype)
  total_spot_count <- sum(spot_count_bycluster$spot_count_bycluster)
  total_celltype_count <- sum(df_sub$celltype_count_by_cluster)

  for (i in 1:nrow(df_sub)) {
    celltype_count_by_cluster <- df_sub$celltype_count_by_cluster[i]
    spot_count_bycluster2 <- df_sub$spot_count_bycluster[i]
    es <- (celltype_count_by_cluster / spot_count_bycluster2) /
          (total_celltype_count / total_spot_count)
    df_sub$enrichment_score_by_celltype[i] <- es
  }

  return(df_sub)
}

# Apply enrichment calculation for all celltypes
celltype_score_enrichment_list <- list()
for (celltype in levels(celltype_proportion_byspotcountcluster$variable)) {
  celltype_score_enrichment_list[[celltype]] <- get_enrichment_score_for_eachcelltype(
    celltype_proportion_byspotcountcluster = celltype_proportion_byspotcountcluster,
    celltype = celltype,
    spot_count_bycluster = integ_clus_vec_spot_count_integrated_snn_res.0.9$integrated_snn_res.0.9
  )
}

# Combine all enrichment results into a single data frame
celltype_score_enrichment_df <- do.call(rbind, celltype_score_enrichment_list)
rownames(celltype_score_enrichment_df) <- NULL


# ---------------------------------------------------------------------------
# Total Celltype Counts & Proportions Across All Clusters
# ---------------------------------------------------------------------------

# Summarize total count per celltype across all clusters
total_celltype_count <- celltype_proportion_byspotcountcluster %>%
  group_by(variable) %>%
  summarise(total_cell_count = sum(celltype_count_by_cluster))

# Compute overall celltype proportions
total_celltype_count$prop <- total_celltype_count$total_cell_count /
                             sum(total_celltype_count$total_cell_count)

# Count celltype totals within each cluster
total_celltype_count_bycluster <- celltype_proportion_byspotcountcluster %>%
  group_by(variable, integrated_snn_res.0.9) %>%
  summarise(total_cell_count = sum(celltype_count_by_cluster))

# ---------------------------------------------------------------------------
# Function: Z-Test for One Celltype in One Cluster (vs. expected proportion)
# ---------------------------------------------------------------------------

Z_test_One_Proportion <- function(
  total_celltype_count_bycluster,
  integ_res,
  cluster_var,
  total_celltype_count,
  celltype
) {
  expected_proportion <- total_celltype_count$prop[
    total_celltype_count$variable == celltype
  ]

  total_celltype_count_bycluster_sub <- total_celltype_count_bycluster[
    total_celltype_count_bycluster[[integ_res]] == cluster_var, ]

  celltype_count <- total_celltype_count_bycluster_sub$total_cell_count[
    total_celltype_count_bycluster_sub$variable == celltype
  ]

  total_celltype_count_percluster <- sum(total_celltype_count_bycluster_sub$total_cell_count)

  # Perform one-tailed binomial proportion test
  prop_test <- prop.test(
    x = celltype_count,
    n = total_celltype_count_percluster,
    p = expected_proportion,
    alternative = "greater"
  )

  return(data.frame(
    celltype = celltype,
    ztestpval = prop_test$p.value,
    cluster = cluster_var
  ))
}

# ---------------------------------------------------------------------------
# Run Z-Tests Across All Celltypes and Clusters
# ---------------------------------------------------------------------------

mydf_list <- list()
cellcolor_names <- levels(celltype_proportion_byspotcountcluster$variable)

for (myclus in unique(celltype_proportion_byspotcountcluster$integrated_snn_res.0.9)) {
  for (mycelltype in cellcolor_names) {
    mydf_list[[paste0(myclus, "_", mycelltype)]] <- Z_test_One_Proportion(
      total_celltype_count_bycluster = total_celltype_count_bycluster,
      integ_res = 'integrated_snn_res.0.9',
      cluster_var = myclus,
      total_celltype_count = total_celltype_count,
      celltype = mycelltype
    )
  }
}

# Combine into single data frame
mydf_list_comb <- do.call(rbind, mydf_list)
rownames(mydf_list_comb) <- NULL

# ---------------------------------------------------------------------------
# Multiple Testing Correction (Bonferroni)
# ---------------------------------------------------------------------------

# Split by celltype for independent adjustment
mydf_list_comb_spl <- split(mydf_list_comb, mydf_list_comb$celltype)

# Apply Bonferroni correction within each celltype
mydf_list_comb_spl2 <- lapply(mydf_list_comb_spl, function(x) {
  mypvals <- data.frame(p.adj = p.adjust(x$ztestpval, method = 'bonferroni'))
  mydf_mod <- cbind(x, mypvals)
  return(mydf_mod)
})

# Combine all adjusted results
mydf_list_comb_spl_comb <- do.call(rbind, mydf_list_comb_spl2)
rownames(mydf_list_comb_spl_comb) <- NULL

# Format and rename columns for final merge
mydf_list_comb_spl_comb2 <- mydf_list_comb_spl_comb[c('celltype', 'cluster', 'p.adj')]
colnames(mydf_list_comb_spl_comb2) <- c('variable', 'integrated_snn_res.0.9', 'p.adj')


# ---------------------------------------------------------------------------
# Merge Enrichment Scores and P-Values
# ---------------------------------------------------------------------------

# Combine enrichment scores and significance test results
celltype_score_enrichment_df2 <- merge(
  celltype_score_enrichment_df,
  mydf_list_comb_spl_comb2,
  by = c('variable', 'integrated_snn_res.0.9')
)

# Add a new column indicating statistical significance
celltype_score_enrichment_df2$Significance <- 'Not Significant'
celltype_score_enrichment_df2$Significance[
  celltype_score_enrichment_df2$p.adj <= 0.05
] <- 'Significant'

# ---------------------------------------------------------------------------
# Define Cluster Groupings (e.g., core-rich, transition, edge-rich)
# ---------------------------------------------------------------------------

group_color_palette <- c("#d7191c", "#fdae61", "#2b83ba", "#abdda4")
names(group_color_palette) <- c('core-rich', 'transition', 'edge-rich', 'non-specific')

group_df <- data.frame(
  Cluster = paste0('C', c(0, 1, 2, 13, 23, 3, 6, 8, 9, 12, 16, 17, 18, 20, 22, 19, 21, 4, 7, 5, 10, 15)),
  group = c(rep('edge-rich', 5), rep('core-rich', 10), rep('transition', 4), rep('non-specific', 3))
)

group_df$group <- factor(group_df$group, levels = c('core-rich', 'transition', 'edge-rich', 'non-specific'))

# ---------------------------------------------------------------------------
# Format Cluster Labels and Merge Groupings
# ---------------------------------------------------------------------------

# Add "C" prefix to cluster labels
celltype_score_enrichment_df2$Cluster <- paste0('C', celltype_score_enrichment_df2$integrated_snn_res.0.9)

# Merge cluster groups into enrichment data
celltype_score_enrichment_df2_grouped <- celltype_score_enrichment_df2 %>%
  left_join(group_df, by = "Cluster")

# Annotate tumor fraction by cluster for downstream plotting
tumor_fraction_df$Cluster <- paste0('C', tumor_fraction_df$integrated_snn_res.0.9)
tumor_fraction_groupeddf <- tumor_fraction_df %>%
  group_by(Cluster) %>%
  summarize(avgtumor_fraction = mean(tumor_fraction))

# ---------------------------------------------------------------------------
# Normalize Celltype Naming (e.g., M1 â†’ S1, etc.)
# ---------------------------------------------------------------------------

celltype_score_enrichment_df2_grouped$celltype <- as.character(celltype_score_enrichment_df2_grouped$variable)

# Rename M states â†’ S states
celltype_score_enrichment_df2_grouped$celltype[celltype_score_enrichment_df2_grouped$variable == 'M1'] <- 'S1'
celltype_score_enrichment_df2_grouped$celltype[celltype_score_enrichment_df2_grouped$variable == 'M2'] <- 'S2'
celltype_score_enrichment_df2_grouped$celltype[celltype_score_enrichment_df2_grouped$variable == 'M3'] <- 'S3'
celltype_score_enrichment_df2_grouped$celltype[celltype_score_enrichment_df2_grouped$variable == 'M4'] <- 'S4'
celltype_score_enrichment_df2_grouped$celltype[celltype_score_enrichment_df2_grouped$variable == 'M5'] <- 'S5'

# Rename oligodendrocyte lineages
celltype_score_enrichment_df2_grouped$celltype[
  celltype_score_enrichment_df2_grouped$variable == "Oligodendrocyte precursor"
] <- "OPC"
celltype_score_enrichment_df2_grouped$celltype[
  celltype_score_enrichment_df2_grouped$variable == "Committed oligodendrocyte precursor"
] <- "C-OPC"
celltype_score_enrichment_df2_grouped$celltype[
  celltype_score_enrichment_df2_grouped$variable == "Oligodendrocyte"
] <- "Oligo"

# ---------------------------------------------------------------------------
# Update Celltype Colors to Match New Naming Conventions
# ---------------------------------------------------------------------------

# Map original names to colors
cellcolor_names <- c(
  "M1", "M2", "M3", "M4", "M5", "TAMs", "Microglia", "Monocyte",
  "CD4_Tcells", "CD8_Tcells", "Other_Tcells", "Vascular", "Fibroblast",
  "Neuron", "Astrocyte", "Committed oligodendrocyte precursor",
  "Oligodendrocyte", "Oligodendrocyte precursor", "DC", "Bcells", "NK/NK-like"
)

latest_cell_colors2 <- c(
  '#E58606', '#6BAED6', '#E7BA52', '#5254A3', '#D66B6F', '#70CCB0', '#91C1B2', '#91C292',
  '#3969AC', '#4C8CE6', '#82C2E8', '#FF4219', 'salmon', 'red4', 'gray90',
  'gray50', 'grey30', 'gray10', "#ffe119", "khaki", "khaki2"
)

# Create color mapping data frame
mycolor_df <- data.frame(celltype = cellcolor_names, cellcolors = latest_cell_colors2)

# Rename for consistency with plot factors
mycolor_df$celltype[mycolor_df$celltype == "M1"] <- "S1"
mycolor_df$celltype[mycolor_df$celltype == "M2"] <- "S2"
mycolor_df$celltype[mycolor_df$celltype == "M3"] <- "S3"
mycolor_df$celltype[mycolor_df$celltype == "M4"] <- "S4"
mycolor_df$celltype[mycolor_df$celltype == "M5"] <- "S5"
mycolor_df$celltype[mycolor_df$celltype == "Oligodendrocyte precursor"] <- "OPC"
mycolor_df$celltype[mycolor_df$celltype == "Committed oligodendrocyte precursor"] <- "C-OPC"
mycolor_df$celltype[mycolor_df$celltype == "Oligodendrocyte"] <- "Oligo"

# ---------------------------------------------------------------------------
# Factor Ordering for Final Plots (Cluster + Celltype)
# ---------------------------------------------------------------------------

# Set cluster order by average tumor fraction (from grouped df)
celltype_score_enrichment_df2_grouped$Cluster <- factor(
  celltype_score_enrichment_df2_grouped$Cluster,
  levels = tumor_fraction_groupeddf$Cluster
)

# Set factor levels for celltype order in plots
celltype_order <- c(
  "S1", "S2", "S3", "S4", "S5", "CD4_Tcells", "CD8_Tcells", "Other_Tcells",
  "Bcells", "NK/NK-like", "DC", "Microglia", "Monocyte", "TAMs", "Astrocyte",
  "C-OPC", "Oligo", "OPC", "Neuron", "Vascular", "Fibroblast"
)

celltype_score_enrichment_df2_grouped$celltype <- factor(
  celltype_score_enrichment_df2_grouped$celltype,
  levels = celltype_order
)

# ---------------------------------------------------------------------------
# Load Cluster-Level Region Annotations from Pathologist
# ---------------------------------------------------------------------------

# Cluster-Level Region Annotations provided in github as example

# dotplot_items2 = readRDS('dotplot_items_list_march13.2025.rds')
# names(dotplot_items2)
# mypercentdf_patient = dotplot_items2$mypercentdf_patient
# tumor_fraction_grouped = dotplot_items2$tumor_fraction_grouped
# group_color_palette = dotplot_items2$group_color_palette
# group_color_palette2 = dotplot_items2$group_color_palette2
# celltype_score_enrichment_df2_grouped = dotplot_items2$celltype_score_enrichment_df2_grouped
# mycolor_df = dotplot_items2$mycolor_df
# group_df = dotplot_items2$group_df



# Load manual region annotations (e.g., Core, Transition, Edge)
mycluster_df <- readRDS("mycluster_df.rds")
colnames(mycluster_df) <- c("Cluster", "region")
mycluster_df$Cluster <- paste0("C", mycluster_df$Cluster)

# Define color scheme for manual region annotation
group_color_palette2 <- c("Core" = "#d7191c", "Transition" = "#4A0080", "Edge" = "#2b83ba")

# Compute percent of spots per region for each cluster
mypercentdf_patient <- as.data.frame(
  prop.table(table(mycluster_df$Cluster, mycluster_df$region), 1) * 100
)
colnames(mypercentdf_patient) <- c("Cluster", "region", "Percentage")
mypercentdf_patient$Cluster <- factor(
  mypercentdf_patient$Cluster,
  levels = levels(celltype_score_enrichment_df2_grouped$Cluster)
)


# ---------------------------------------------------------------------------
# Set Unified Plot Styling
# ---------------------------------------------------------------------------

text_size <- 20
legend_text_size <- 16
legend_title_size <- 18

# ---------------------------------------------------------------------------
# BARPLOT: % of Pathologist-Defined Regions Per Cluster
# ---------------------------------------------------------------------------

barplot <- ggplot(mypercentdf_patient, aes(fill = region, y = Percentage, x = Cluster)) +
  geom_bar(stat = "identity", position = "fill", alpha = 0.9, color = "black", linewidth = 0.05) +
  scale_fill_manual(values = group_color_palette2) +
  labs(x = 'Cluster', y = "Pathologist annotations") +
  theme_minimal() +
  theme(
    text = element_text(size = text_size),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.y = element_text(size = text_size),
    axis.title.y = element_text(size = text_size),
    legend.text = element_text(size = legend_text_size),
    legend.title = element_text(size = legend_title_size),
    legend.position = "right"
  ) +
  guides(fill = guide_legend(title = "Pathologist annotations"))

# ---------------------------------------------------------------------------
# BOX PLOT: Tumor Fraction Per Cluster
# ---------------------------------------------------------------------------

boxplot <- ggplot(tumor_fraction_df, aes(x = Cluster, y = tumor_fraction, fill = Cluster)) +
  geom_boxplot(alpha = 0.6) +
  scale_fill_manual(values = group_color_palette, name = "Clusters") +
  theme_minimal() +
  labs(x = "Cluster", y = "Tumor Fraction") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, size = text_size),
    axis.title = element_text(size = text_size),
    axis.text.y = element_text(size = text_size),
    legend.position = "none"
  )

# ---------------------------------------------------------------------------
# DOTPLOT: Celltype Enrichment by Cluster
# ---------------------------------------------------------------------------

library(ggnewscale)

dotplot <- ggplot(celltype_score_enrichment_df2_grouped,
                  aes(x = Cluster, y = celltype, fill = celltype, size = enrichment_score_by_celltype)) +

  geom_point(aes(stroke = ifelse(Significance == "Significant", 3, 0),
                 color = Significance), shape = 21) +

  scale_size_continuous(range = c(2, 22), name = "Enrichment Score") +

  scale_color_manual(values = c("Significant" = "black", "Non-significant" = NA),
                     name = "Significance",
                     guide = guide_legend(title = "Significance",
                                          override.aes = list(size = 8, stroke = 2),
                                          title.theme = element_text(size = legend_title_size, face = "bold"),
                                          label.theme = element_text(size = legend_text_size, face = "bold"))) +

  scale_fill_manual(values = setNames(mycolor_df$cellcolors, mycolor_df$celltype),
                    guide = guide_legend(title = "Celltypes",
                                         override.aes = list(size = 8, stroke = 1.5),
                                         title.theme = element_text(size = legend_title_size, face = "bold"),
                                         label.theme = element_text(size = legend_text_size, face = "bold"))) +

  ggnewscale::new_scale_fill() +

  # Add top color bar for cluster grouping
  geom_tile(data = celltype_score_enrichment_df2_grouped %>%
              distinct(Cluster, group),
            aes(x = Cluster, y = -0.5, fill = group),
            inherit.aes = FALSE, height = 1) +

  scale_fill_manual(values = group_color_palette,
                    name = "Cluster Group",
                    guide = guide_legend(title = "Cluster Group",
                                         override.aes = list(size = 8),
                                         title.theme = element_text(size = legend_title_size),
                                         label.theme = element_text(size = legend_text_size))) +

  geom_vline(xintercept = seq(1.5, length(unique(celltype_score_enrichment_df2_grouped$Cluster)) - 0.5, by = 1),
             linetype = "dotted", color = "black", linewidth = 0.5) +

  geom_hline(yintercept = seq(1.5, length(unique(celltype_score_enrichment_df2_grouped$celltype)) - 0.5, by = 1),
             linetype = "dotted", color = "black", linewidth = 0.5) +

  cowplot::theme_cowplot() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.y = element_text(size = text_size, face = "bold"),
    axis.title.y = element_text(size = text_size, face = "bold"),
    legend.text = element_text(size = legend_text_size),
    legend.title = element_text(size = legend_title_size),
    legend.position = "top",
    plot.margin = unit(c(0, 0, 0, 0), "cm")
  ) +
  labs(y = "Celltype Enrichment Score")

# ---------------------------------------------------------------------------
# Combine Dotplot, Barplot, and Boxplot using patchwork
# ---------------------------------------------------------------------------

# Ensure the barplot has no vertical margins for tight stacking
barplot <- barplot + theme(plot.margin = unit(c(0, 0, 0, 0), "cm"))
boxplot <- boxplot + theme(plot.margin = unit(c(0, 0, 0, 0), "cm"))

# Combine: Dotplot on top, barplot in middle, boxplot at bottom
combined_plot <- (dotplot / barplot) / boxplot +
  patchwork::plot_layout(ncol = 1, heights = c(4, 1, 0.5))  # Proportional heights

# ---------------------------------------------------------------------------
# Print and Save Composite Plot
# ---------------------------------------------------------------------------

# View in current R session
print(combined_plot)

# Auto-generate filename with current date
output_file <- paste0(
  "combined_plot_with_uniform_legend_sizes.sortedbyavgtumorfractionwithingroups.rowscolsclustered.",
  date,
  ".jpg"
)

# Save high-res output
ggsave(
  filename = output_file,
  plot = combined_plot,
  width = 30,
  height = 22.5,
  units = "in",
  dpi = 300
)